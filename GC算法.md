## JVM

### JVM运行时数据区

### GC算法

##### 引用计数器算法

###### 描述

```java
给每个对象分配一个计数器 当对象被引用一次则+1 反之亦然 若某对象的引用计数器为0 则可以删除
JVM一般不使用此算法    
```

###### 优点

```java
没有
```

###### 缺点

```java
需要额外维护计数器 成本过高 会产生内存碎片
```

##### 复制算法

###### 描述

```java
Survivor区其中一个（From区）配合Eden区使用，当进行Minor GC的时候 把存活下来的对象复制到另一个Survivor区（To区域）
To区放了所有的存活对象 而Eden From都空了 然后To区和From区进行逻辑交换 From rename-> To,To rename-> From 
此时Eden继续和From配合工作 而此时To区为空继续等待下一次Minor GC
原理和冒泡算法类似 To区作为一个交换区
```

GC前：

![image-20210202132804288](https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514004232276-984785021.png)

GC后：

![](https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514004237536-1710367861.png)

###### 优点

```java
复制算法不会产生内存碎片
```

###### 缺点

```java
占用内存 适用于对象存活特别低的场景
```

##### 标记清除算法

###### 描述

```java
当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。
标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
清除：遍历整个堆，把未标记的对象清除。    
```

![image-20210202134154066](https://img2018.cnblogs.com/blog/1522745/202001/1522745-20200120174155809-391256654.png)

###### 优点

```java
相比复制算法 不需要双倍空间
```

###### 缺点

```java
因为要遍历整个堆 效率低
会造成程序中止 用户体验不好
清理后会产生内存碎片 JVM需要维护一个内存的空闲列表 浪费资源    
```

##### 标记压缩算法

###### 描述

```java
在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。
标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
```

![image-20210202134136071](https://img2018.cnblogs.com/blog/1522745/202001/1522745-20200120174218465-2097322430.png)

###### 优点

```java
避免了复制算法的双倍空间 避免了标记清除算法的内存碎片
```

###### 缺点

```java
要整理所有存活对象的引用地址 效率上低于复制算法 
```

##### 标记清除压缩算法

###### 描述

```java
标记清除算法和标记压缩算法配合使用 n次清除一次压缩
```



